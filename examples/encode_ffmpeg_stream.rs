// This example demonstrates how to encode an audio stream from ffmpeg's stdout
// into a .qoa file. It spawns an ffmpeg process to generate a sine wave,
// captures its raw PCM output, and then encodes this data using the qoaudio library.
//
// To run this example:
// 1. Ensure ffmpeg is installed and accessible in your system's PATH.
// 2. Execute: cargo run --example encode_ffmpeg_stream
// The output will be a file named "ffmpeg_output.qoa" in the current directory.

use std::io::{BufWriter, Read}; // Read is used for ffmpeg stdout
use std::process::{Command, Stdio, ChildStdout};
use std::fs::File;
// Crate name is qoaudio based on Cargo.toml
use qoaudio::{QoaEncoder, EncodeError, QOA_SLICE_LEN}; // QOA_SLICE_LEN is used for frame calculations

// --- Audio Parameters ---
/// Sample rate in Hz for the generated audio.
const SAMPLE_RATE: u32 = 44100;
/// Number of audio channels.
const NUM_CHANNELS: u8 = 2;
/// Duration of the audio to be generated by ffmpeg, in seconds.
const DURATION_SECONDS: u32 = 5;
/// Total number of samples expected per channel for the entire audio stream.
const TOTAL_SAMPLES_PER_CHANNEL: u32 = SAMPLE_RATE * DURATION_SECONDS;

// --- QOA Encoding Parameters ---
/// Defines the number of samples per channel that will be processed in each iteration
/// when reading from ffmpeg and passing to the QOA encoder.
/// This is set to QOA's maximum frame size (256 slices * 20 samples/slice).
const SAMPLES_PER_CHANNEL_PER_ENCODER_FRAME: usize = 256 * QOA_SLICE_LEN;

/// Main function orchestrates the ffmpeg process, QOA encoding, and data streaming.
fn main() -> Result<(), Box<dyn std::error::Error>> {
    eprintln!("Starting example: Encode audio stream from ffmpeg to QOA format.");

    // Output QOA filename (can be made configurable later)
    let output_qoa_filename = "ffmpeg_output.qoa";

    // --- 1. Spawn ffmpeg process ---
    // This section configures and spawns an ffmpeg process.
    // ffmpeg is used here to generate a predictable audio stream (a sine wave)
    // and output it as raw PCM data to its standard output.
    eprintln!("Spawning ffmpeg process...");

    let ffmpeg_cmd = "ffmpeg"; // Assumes ffmpeg is in PATH
    let mut cmd = Command::new(ffmpeg_cmd);
    cmd.arg("-f", "lavfi") // Input format: libavfilter graph
       .arg("-i", &format!("sine=frequency=440:duration={}:sample_rate={}", DURATION_SECONDS, SAMPLE_RATE)) // Input source: sine wave
       .arg("-ac", &NUM_CHANNELS.to_string()) // Number of audio channels for output
       .arg("-f", "s16be") // Output format: signed 16-bit PCM, big-endian
       .arg("-ar", &SAMPLE_RATE.to_string()) // Output sample rate
       .arg("-") // Output destination: stdout
       .stdout(Stdio::piped()) // Capture stdout of ffmpeg
       .stderr(Stdio::inherit()); // Pass through stderr from ffmpeg for live error reporting

    // Spawn the ffmpeg child process.
    let mut ffmpeg_child = match cmd.spawn() {
        Ok(child) => child,
        Err(e) => {
            if e.kind() == std::io::ErrorKind::NotFound {
                eprintln!("Error: ffmpeg command not found. Please ensure ffmpeg is installed and in your PATH.");
            } else {
                eprintln!("Error spawning ffmpeg: {}", e);
            }
            return Err(Box::new(e));
        }
    };

    let mut ffmpeg_stdout: ChildStdout = ffmpeg_child.stdout.take()
        .ok_or_else(|| std::io::Error::new(std::io::ErrorKind::Other, "Failed to capture ffmpeg stdout"))?;

    // Placeholder for subsequent logic (now removed)
    // eprintln!("ffmpeg stdout captured.");

    // --- 2. Initialize QOA Encoder ---
    // Sets up the QoaEncoder to write the encoded audio data to a .qoa file.
    eprintln!("Initializing QOA encoder for output to {}...", output_qoa_filename);
    let output_file = match File::create(output_qoa_filename) { // Create the output .qoa file
        Ok(file) => file,
        Err(e) => {
            eprintln!("Error creating output file {}: {}", output_qoa_filename, e);
            return Err(Box::new(e));
        }
    };
    let writer = BufWriter::new(output_file);

    // TOTAL_SAMPLES_PER_CHANNEL is already defined at the top of the file
    // from SAMPLE_RATE * DURATION_SECONDS.
    // NUM_CHANNELS and SAMPLE_RATE are also global constants in this example.
    let mut encoder = match QoaEncoder::new(writer, NUM_CHANNELS, SAMPLE_RATE, TOTAL_SAMPLES_PER_CHANNEL) {
        Ok(enc) => enc,
        Err(e) => {
            eprintln!("Error initializing QOA encoder: {:?}", e);
            return Err(Box::new(e)); // EncodeError implements std::error::Error
        }
    };

    // Placeholder for subsequent logic (streaming loop) (now removed)
    // eprintln!("QOA Encoder initialized.");

    // --- 3. Stream Data from ffmpeg to QOA Encoder ---
    // This loop reads PCM data from ffmpeg's stdout, de-interleaves it,
    // and encodes it frame by frame into the QOA format.
    eprintln!("Reading from ffmpeg stdout and encoding to QOA...");

    // Constant for bytes per sample (i16 = 2 bytes).
    const BYTES_PER_SAMPLE: usize = 2;

    let mut total_samples_processed_per_channel: usize = 0;

    loop {
        // Determine how many samples per channel are needed for the current encoder frame.
        // This handles the last frame, which might be smaller than SAMPLES_PER_CHANNEL_PER_ENCODER_FRAME.
        let remaining_samples_per_channel = TOTAL_SAMPLES_PER_CHANNEL as usize - total_samples_processed_per_channel;
        if remaining_samples_per_channel == 0 {
            break; // All expected samples have been processed.
        }

        let current_frame_samples_per_channel = remaining_samples_per_channel.min(SAMPLES_PER_CHANNEL_PER_ENCODER_FRAME);
        let bytes_to_read_for_this_frame = current_frame_samples_per_channel * NUM_CHANNELS as usize * BYTES_PER_SAMPLE;

        // Read the exact number of bytes required for the current processing frame from ffmpeg.
        let mut current_frame_raw_bytes = vec![0u8; bytes_to_read_for_this_frame];
        match ffmpeg_stdout.read_exact(&mut current_frame_raw_bytes) {
            Ok(_) => {}, // Data read successfully.
            Err(ref e) if e.kind() == std::io::ErrorKind::UnexpectedEof => {
                // ffmpeg produced fewer bytes than expected (based on DURATION_SECONDS).
                // This can happen if ffmpeg's duration calculation is slightly different,
                // or if the stream ends prematurely for other reasons.
                eprintln!("ffmpeg stdout Unexpected EOF. Expected more data. Processed samples per channel: {}", total_samples_processed_per_channel);
                // Break the loop; QoaEncoder::finish() will verify the total sample count later if it's strict.
                break;
            }
            Err(e) => {
                // Handle other read errors.
                eprintln!("Error reading from ffmpeg stdout: {}", e);
                return Err(Box::new(e));
            }
        }

        // This check is mostly redundant if read_exact succeeds or handles EOF,
        // but kept as a safeguard. If read_exact returns Ok, the buffer is full.
        // If it returns UnexpectedEof, the loop breaks above.
        if current_frame_raw_bytes.is_empty() {
            break; // Should not be reached if read_exact logic is sound.
        }

        // De-interleave the raw PCM data (s16be) into separate channels.
        // QoaEncoder expects data as Vec<Vec<i16>> (Vec of channels, each channel a Vec of samples).
        let mut samples_for_encoder_frame: Vec<Vec<i16>> = vec![Vec::with_capacity(current_frame_samples_per_channel); NUM_CHANNELS as usize];
        for i in 0..current_frame_samples_per_channel { // For each sample index in the frame
            for chan_idx in 0..NUM_CHANNELS as usize { // For each channel
                let byte_offset = (i * NUM_CHANNELS as usize + chan_idx) * BYTES_PER_SAMPLE;
                let sample_bytes = [current_frame_raw_bytes[byte_offset], current_frame_raw_bytes[byte_offset + 1]];
                samples_for_encoder_frame[chan_idx].push(i16::from_be_bytes(sample_bytes));
            }
        }

        // Write the prepared frame data to the QOA encoder.
        if let Err(e) = encoder.write_frame(&samples_for_encoder_frame) {
            eprintln!("Error writing frame to QOA encoder: {:?}", e);
            return Err(format!("QOA Encoder write_frame error: {:?}", e).into());
        }

        total_samples_processed_per_channel += current_frame_samples_per_channel;
        eprintln!("Processed frame: {} / {} samples per channel", total_samples_processed_per_channel, TOTAL_SAMPLES_PER_CHANNEL);
    }

    // Check if the number of processed samples matches the expectation from DURATION_SECONDS.
    // This is a soft check; QoaEncoder::finish() performs a strict check based on its initialization.
    if total_samples_processed_per_channel != TOTAL_SAMPLES_PER_CHANNEL as usize {
        eprintln!("Warning: Processed {} samples per channel, but expected {}. ffmpeg might have ended stream prematurely or sent partial final data.", total_samples_processed_per_channel, TOTAL_SAMPLES_PER_CHANNEL);
    }

    // Placeholder for encoder.finish() (now removed as it's the next step)
    // eprintln!("Finished reading from ffmpeg.");

    // --- 4. Finalize QOA Encoding and ffmpeg Process ---
    // Finalizes the QOA stream (e.g., flushes buffers) and waits for ffmpeg to exit.
    eprintln!("Finalizing QOA encoding...");
    if let Err(e) = encoder.finish() { // Call finish on the QOA encoder.
        eprintln!("Error finalizing QOA encoder: {:?}", e);
        // Attempt to wait for ffmpeg child to avoid a zombie process, even if encoding failed.
        // The result of wait() is ignored here as we are already handling an error.
        let _ = ffmpeg_child.wait();
        return Err(format!("QOA Encoder finish error: {:?}", e).into());
    }

    // Wait for the ffmpeg child process to complete and check its exit status.
    eprintln!("Waiting for ffmpeg process to complete...");
    let status = match ffmpeg_child.wait() { // Wait for ffmpeg to terminate.
        Ok(s) => s,
        Err(e) => {
            eprintln!("Failed to wait for ffmpeg child process: {}", e);
            // This doesn't necessarily mean encoding failed if all data was piped,
            // but it's an issue to note.
            return Err(Box::new(e));
        }
    };

    if !status.success() {
        eprintln!("ffmpeg process exited with error status: {}", status);
        // Return an error, as ffmpeg might not have produced all data or indicated an issue.
        return Err(format!("ffmpeg process failed: {}", status).into());
    }
    eprintln!("ffmpeg process completed successfully.");

    eprintln!("Encoding finished successfully to {}.", output_qoa_filename);
    Ok(())
}
